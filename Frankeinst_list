#ifndef FRANKENSTEIN_LIST
#define FRANKENSTEIN_LIST
#include <iostream>
template <typename T>
class frankenstein_list
{

public:
	frankenstein_list() {
		size = 0;
		head = nullptr;
		tail = nullptr;
		head_asc = nullptr;
		head_desc = nullptr;
	}

	~frankenstein_list()
	{
		Node<T>* cur = head;
		Node<T>* tmp = cur;
		while (cur) {
			tmp = cur;
			cur = cur->next;
			delete tmp;
		}
	}

	void pop_back();
	void pop_front();
	void print();
	void push_back(T data);
	void push_front(T data);
	void insert(int,T);
	void print_decrease();
	void print_ascending();
	int getsize() {
		return size;
	}

private:

	template <typename T>
	class Node {


	public:
		Node(T data, Node<T>* next = nullptr,Node<T>* prev=nullptr,Node<T>* asc=nullptr,Node<T>* desc=nullptr) {
			this->data = data;
			this->next = next;
			this->asc = asc;
			this->desc = desc;
			this->prev = prev;
		}
		T data;
		
		Node<T>* next;
		Node<T>* prev;
		Node<T>* asc;
		Node<T>* desc;
		
	};
	Node<T>* head;
	Node<T>* tail;
	Node<T>* head_desc;
	Node<T>* head_asc;
	int size;
	void pushsorted(Node<T>* node) {
		
		if (head_desc==nullptr) {
			head_desc = node;
			head_asc = node;
			return;
		}

		Node<T>* tmp = head_asc;
		while (tmp->data < node->data && tmp->asc) {
			tmp = tmp->asc;
		}
		if (node->data > tmp->data) {
			node->asc = tmp->asc;
			tmp->asc = node;
			node->desc = tmp;
			if (!node->asc) {
				head_desc = node;
			}
		}

		else {
			node->desc = tmp->desc;
			if (tmp->desc) {
				tmp->desc->asc = node;
			}
			else {
				head_asc = node;
			}
			node->asc = tmp;
			tmp->desc= node;
		}



	}
	
	
	void popsort(Node<T>*);

};

template <typename T>
void frankenstein_list<T>::push_front(T data) {
	Node<T>* node = new Node<T>(data);
	Node<T>* tmp = head;
	head->prev = node;
	node->prev = nullptr;
	head = node;
	node->next = tmp;
	pushsorted(node);
	++size;

}
template <typename T> 
void frankenstein_list<T>::push_back(T data) {
	
		Node<T>* node = new Node<T>(data);
		node->prev = tail;
	
		if (tail) {
			tail->next = node;
		}
		else {
			head = node;
		}
		tail = node;
	
		
		++size;
		pushsorted(node);
}

template <typename T>
void frankenstein_list<T>::print_ascending() {
	Node<T>* tmp = head_asc;
	while (tmp!=nullptr) {
		std::cout << tmp->data<<"  ";
		tmp = tmp->asc;
	}
	std::cout << std::endl;
}

template <typename T>
void frankenstein_list<T>::print_decrease() {
	Node<T> *tmp = head_desc;
	while (tmp != nullptr) {
		std::cout << tmp->data << "  ";
		tmp = tmp->desc;
	}
	std::cout << std::endl;
}

template <typename T>
void frankenstein_list<T>::insert(int index, T data1) {
	
	Node<T>* ind = this->head;
	
	if (index == 0) {

		push_front(data1);

		return;
	}
	else {
		Node<T>* node = new Node<T>(data1);
		pushsorted(node);
		while (index != 1) {

			
			ind = ind->next;

			index--;
		}
	
	
		node->next = ind->next;
		ind->next->prev = node;
		ind->next = node;
		node->prev = ind;
		
	}
	++size;
}

template <typename T>
void frankenstein_list<T>::print() {
	Node<T>* tmp = tail;
	while (tmp!=nullptr) {
		std::cout << tmp->data << " ";
		tmp = tmp->prev;
	}
}


template <typename T>
void frankenstein_list<T>::pop_back() {
	
	if (tail->prev == nullptr) {
		head = nullptr;
		head_asc = nullptr;
		head_desc = nullptr;
		delete tail;
		tail = nullptr;
		return;
	}

		Node<T>* tmp = tail;
	popsort(tmp);
	
	tail = tail->prev;
	delete tmp;
	tail->next = nullptr;
	--size;


}


template <typename T>
void frankenstein_list<T>::pop_front() {
	if (head->next== nullptr) {
		tail = nullptr;
		head_asc = nullptr;
		head_desc = nullptr;
		delete head;
		head = nullptr;
		return;
	}
	Node<T>* tmp = head;
	popsort(tmp);
	head=head->next;
	delete tmp;
	head->next = nullptr;
	--size;
}

template <typename T>
void frankenstein_list<T>::popsort(Node<T>* node) {
	if (node == head_desc) {
		head_desc = head_desc->desc;
		head_desc->asc = nullptr;
		return;
	}
	else if(node==head_asc){
		head_asc = head_asc->asc;
		head_asc->desc = nullptr;
		return;
	}
	else {
		node->asc->desc = node->desc;
		node->desc->asc = node->asc;
	}
}


#endif //FRANK-LIST
